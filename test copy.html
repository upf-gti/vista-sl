<html>
    <head>
        <title>VISTA-SL Demo</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="icon" type="image/x-icon" href="https://avatars.slack-edge.com/2025-04-17/8790996987232_b71f912cab2b8dbb26e6_88.jpg">
        <link rel="stylesheet" href="https://cdn.skypack.dev/lexgui@0.6.9/build/lexgui.css">
        <style>
            html, body { width:100%; height:100%; margin:0; padding:0; overflow:hidden; }
        </style>
        <script src="./external/jquery-3.6.0.min.js"></script>
        <script async src="./external/es-module-shims.js"></script>

        <script type="importmap">
			{
				"imports": {
					"three": "./external/three/build/three.module.js",
                    "three/addons/": "./external/three/jsm/",
                    "lexgui": "https://cdn.skypack.dev/lexgui@0.6.9/build/lexgui.module.js",
                    "lexgui/components/": "https://cdn.skypack.dev/lexgui@0.6.9/build/components/"
                }
            }
		</script>
    </head>
    <body>
      

            <script type="module" >
     
                            import * as THREE from 'three';
            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
            import { BVHLoader } from 'three/addons/loaders/BVHLoader.js';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

            let scene, camera, renderer, mixer, clock;
            const handTrajectories = []; // Save trajectory of each finger

            init();
            loadModel();

            function init() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x202020);

                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
                camera.position.set(0, 1.6, 3);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                new OrbitControls(camera, renderer.domElement);

                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(1, 2, 3);
                scene.add(light);

                const ambient = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambient);

                clock = new THREE.Clock();
            }

            function loadModel() {
                const loader = new GLTFLoader();
                const bvhloader = new BVHLoader();
                loader.load('https://resources.gti.upf.edu/3Dcharacters/Eva_Low/Eva_Low.glb', (gltf) => {
                    const model = gltf.scene;
                    model.name = "character";
                    scene.add(model);
                    loader.load('animations.glb', (gltf) => {
                        // Assume first animation is the one we want
                        const clip = gltf.animations[0];
                        // Create mixer
                        mixer = new THREE.AnimationMixer(model);
                        const action = mixer.clipAction(clip);
                        action.play();
                
                        // Identify hand bones
                        const fingerBoneNames = [
                            { base: 'mixamorig_LeftHandIndex1', tip: 'mixamorig_LeftHandIndex4' },
                            { base: 'mixamorig_LeftHandMiddle1', tip: 'mixamorig_LeftHandMiddle4' },
                            { base: 'mixamorig_LeftHandRing1', tip: 'mixamorig_LeftHandRing4' },
                            { base: 'mixamorig_LeftHandPinky1', tip: 'mixamorig_LeftHandPinky4' },
                            { base: 'mixamorig_LeftHandThumb1', tip: 'mixamorig_LeftHandThumb3' } // Thumb may have fewer bones
                        ];
                
                        const palm = model.getObjectByName('mixamorig_LeftHand');
                
                        if (!palm) {
                            console.warn('No palm bone found');
                            return;
                        }
                
                        // Precompute trajectory for each finger
                        
                        const duration = clip.duration;
                        const sampleRate = 60; // samples per second
                        const numSamples = Math.floor(duration * sampleRate);
                        fingerBoneNames.forEach((finger, i) => {
                            const baseBone = model.getObjectByName(finger.base);
                            const tipBone = model.getObjectByName(finger.tip);
                            
                            if (!baseBone || !tipBone) {
                                console.warn(`Missing bone: ${finger.base} or ${finger.tip}`);
                                return;
                            }
                            
                            const points = [];
                            
                            for (let frame = 0; frame < numSamples; frame++) {
                                const time = (frame / sampleRate);
                                mixer.setTime(time);
                                model.updateWorldMatrix(false, true);

                                // model.traverse((child) => {
                                //     if (child.isBone || child.isSkinnedMesh) {
                                //         child.updateMatrix();
                                //         child.updateMatrixWorld(true);
                                //     }
                                // });
                                
                                // const baseBone = model.getObjectByName(finger.base);
                                // const tipBone = model.getObjectByName(finger.tip);
                                // tipBone.updateMatrix();
                                // let bone = tipBone;

                                // let matrixWorld = new THREE.Matrix4().copy(bone.matrix);
                                // while(bone.name != finger.base) {
                                //     bone.parent.updateMatrix();
                                //     matrixWorld.premultiply(bone.parent.matrix)
                                //     bone = bone.parent;
                                // }
                                
                                // // Get global position of tip finger
                                // const tipWorld = new THREE.Vector3();
                                // matrixWorld.decompose(tipWorld, new THREE.Quaternion(), new THREE.Vector3());
                                // //tipBone.getWorldPosition(tipWorld);

                                // // Transform global position to local position of the palm
                                // palm.updateMatrixWorld(true);
                                // const palmMatrixWorld = palm.matrixWorld;
                                // const palmMatrixWorldInverse = new THREE.Matrix4().copy(palmMatrixWorld).invert();

                                // const tipLocal = tipWorld.clone().applyMatrix4(palmMatrixWorldInverse);


                                // points.push(tipLocal.clone());
                                // points.push(tipWorld);


                                // Get global position of tip finger
                                const tipWorld = new THREE.Vector3();
                                const tipBone = model.getObjectByName(finger.tip);
                                tipBone.getWorldPosition(tipWorld);

                                const palmPosition = new THREE.Vector3();
                                palm.getWorldPosition(palmPosition);

                                tipWorld.sub(palmPosition);
                                points.push(tipWorld);
                            }

                            // Create geometry
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const material = new THREE.LineBasicMaterial({
                                color: new THREE.Color(`hsl(${i * 60}, 100%, 50%)`),
                            });
                            const line = new THREE.Line(geometry, material);

                            // Add line as a palm child
                            model.add(line);
                            handTrajectories.push(line);
                        mixer.timeScale = 0.1;

                        });
                
                        animate();
                    })

                });
            }

            function animate() {
                requestAnimationFrame(animate);

                const delta = clock.getDelta();
                if (mixer) mixer.update(delta);
                const palm = scene.getObjectByName("mixamorig_LeftHand");
                const palmPosition = palm.getWorldPosition(new THREE.Vector3());
                for(let i = 0; i < handTrajectories.length; i++) {
                    handTrajectories[i].position.copy(palmPosition);
                }
                renderer.render(scene, camera);
            }

            </script>

    </body>
</html>